<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Azure.SignalR.Protocols</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ArrayDictionary`2">
            <summary>
            Lightweight, read-only IDictionary implementation using two arrays
            and O(n) lookup.
            Requires specifying capacity at construction and does not
            support reallocation to increase capacity.
            ref: https://github.com/dotnet/dotnet/blob/main/src/msbuild/src/Build/Collections/ArrayDictionary.cs
            </summary>
            <typeparam name="TKey">Type of keys</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage">
            <summary>
            Base class of check-with-ack messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage">
            <summary>
            A waiting for ack check-user-in-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckUserInGroupWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name to check whether the user is in or not.</param>
            <param name="ackId">The ack Id.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage">
            <summary>
            A waiting for ack check-any-connection-in-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckGroupExistenceWithAckMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage">
            <summary>
            A waiting for ack check-connection-existence message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckConnectionExistenceWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage">
            <summary>
            A waiting for ack check-user-existence message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage.#ctor(System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CheckUserExistenceWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.AckId">
            <summary>
            Gets or sets the ack Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseWithAckMessage.Reason">
            <summary>
            Gets or sets the reason for the close.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseMultiConnectionsWithAckMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage">
            <summary>
            A close-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id for the connection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage">
            <summary>
            Close all the connections in the hub.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionsWithAckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage">
            <summary>
            Close connections for a user.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseUserConnectionsWithAckMessage"/> class.
            </summary>
            <param name="userId">The user Id for the message.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage">
            <summary>
            Close connections in a group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage.#ctor(System.String,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseGroupConnectionsWithAckMessage"/> class.
            </summary>
            <param name="groupName">The group name for the message.</param>
            <param name="ackId">The ack Id for the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionMessage">
            <summary>
            Base class of connection-specific messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage">
            <summary>
            A open-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.#ctor(System.String,System.Security.Claims.Claim[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="claims">An array of <see cref="T:System.Security.Claims.Claim"/> associated with the connection.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.#ctor(System.String,System.Security.Claims.Claim[],System.Collections.Generic.IDictionary{System.String,Microsoft.Extensions.Primitives.StringValues},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="claims">An array of <see cref="T:System.Security.Claims.Claim"/> associated with the connection.</param>
            <param name="headers">A <see cref="T:System.Collections.Generic.IDictionary`2"/> associated with the connection.</param>
            <param name="queryString">Query string associated with the connection.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Claims">
            <summary>
            Gets or sets the associated claims.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Headers">
            <summary>
            Gets or sets the associated headers.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.QueryString">
            <summary>
            Gets or sets the associated query string.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.OpenConnectionMessage.Protocol">
            <summary>
            Gets or sets the protocol for new connection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage">
            <summary>
            A close-connection message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.#ctor(System.String,System.String,System.Collections.Generic.IDictionary{System.String,Microsoft.Extensions.Primitives.StringValues})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="errorMessage">Optional error message.</param>
            <param name="headers">A <see cref="T:System.Collections.Generic.IDictionary`2"/> associated with the connection.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.#ctor(System.String)">
            <summary>
            Test only
            </summary>
            <param name="connectionId"></param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.ErrorMessage">
            <summary>
            Gets or sets the error message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.CloseConnectionMessage.Headers">
            <summary>
            Gets or sets the associated headers.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage">
            <summary>
            A connection data message.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.#ctor(System.String,System.ReadOnlyMemory{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="payload">Binary data to be delivered.</param>
            <param name="tracingId">The tracing Id of the message</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.#ctor(System.String,System.Buffers.ReadOnlySequence{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="payload">Binary data to be delivered.</param>
            <param name="tracingId">The tracing Id of the message</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.Payload">
            <summary>
            Gets or sets the binary payload.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.TracingId">
            <summary>
            Gets or sets the message ID
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.Type">
            <summary>
            Gets or sets the type of payload.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ConnectionDataMessage.IsPartial">
            <summary>
            Gets or sets the payload is partial or not.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionReconnectMessage">
            <summary>
            A signal for client connection reconnect.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionReconnectMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ConnectionReconnectMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage">
            <summary>
            Base class of client invocation completion messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.InvocationId">
            <summary>
            Gets or sets the client invocation Id of pending connection.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.CallerServerId">
            <summary>
            Gets or sets the server Id which parse the completion message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceCompletionMessage.TracingId">
            <summary>
            Gets or sets the message ID
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage">
            <summary>
            A data message of client invocation completion result.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.#ctor(System.String,System.String,System.String,System.String,System.ReadOnlyMemory{System.Byte},System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage"/> class.
            </summary>
            <param name="invocationId">The Id of the invocation that has completed.</param>
            <param name="connectionId">The client connection Id that complete the invocation.</param>
            <param name="callerServerId">The serverId that wrap the completion result.</param>
            <param name="protocol">The protocol of the connection.</param>
            <param name="payload">The payload of the completion result.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.Protocol">
            <summary>
            Gets or sets the connection protocol.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage.Payload">
            <summary>
            Gets or sets the binary payload.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage">
            <summary>
            An error response indicates client invocation failed with details.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage.#ctor(System.String,System.String,System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientCompletionMessage"/> class with error information.
            </summary>
            <param name="invocationId">The Id of the invocation that has completed.</param>
            <param name="connectionId">The client connection Id that complete the invocation.</param>
            <param name="callerServerId">The serverId that wrap the completion result.</param>
            <param name="error">The error information about invacation failure.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ErrorCompletionMessage.Error">
            <summary>
            Gets or sets the error message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType">
            <summary>
            The type of service event object.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.ServiceInstance">
            <summary>
            The instance of service.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.Connection">
            <summary>
            The connection.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.User">
            <summary>
            The user.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.Group">
            <summary>
            The group.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType.ServerConnection">
            <summary>
            The server connection.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventKind">
            <summary>
            The kind of service event.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.Reloading">
            <summary>
            The reloading event.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.Invalid">
            <summary>
            The format of id is invalid.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.NotExisted">
            <summary>
            The id is not existed.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ServiceEventKind.BufferFull">
            <summary>
            The buffer-full event. When the server is sending too many messages at the same time, the service would back-pressure the messages to the server-side and also trigger this `BufferFull` event.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.DataMessageType">
            <summary>
            The type of data message.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.DataMessageType.Unknown">
            <summary>
            Unknown.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.DataMessageType.Handshake">
            <summary>
            Handshake request or handshake response.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.DataMessageType.Invocation">
            <summary>
            Any kind of invocations.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.DataMessageType.Other">
            <summary>
            Others, include ping, ack, sequence.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.DataMessageType.Close">
            <summary>
            Close message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage">
            <summary>
            A join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage">
            <summary>
            A leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage">
            <summary>
            A user-join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.Ttl">
            <summary>
            Time to live for the user in the group.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, to which the user will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage">
            <summary>
            A user-leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, from which the user will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage">
            <summary>
            A waiting for ack user-join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.Ttl">
            <summary>
            Time to live for the user in the group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserJoinGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserJoinGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, to which the user will join.</param>
            <param name="ackId">The ack Id.</param>
            <param name="ttl">Time to live for the user in the group.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage">
            <summary>
            A waiting for ack  user-leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserLeaveGroupMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="groupName">The group name, from which the user will leave.</param>
            <param name="ackId">The ack Id.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage">
            <summary>
            A waiting for ack join-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.JoinGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, to which the connection will join.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage">
            <summary>
            A waiting for ack leave-group message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage.#ctor(System.String,System.String,System.Int32,System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.LeaveGroupWithAckMessage"/> class.
            </summary>
            <param name="connectionId">The connection Id.</param>
            <param name="groupName">The group name, from which the connection will leave.</param>
            <param name="ackId">The ack Id</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.IServiceProtocol">
            <summary>
            A protocol abstraction for communication between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.Version">
            <summary>
            Gets the version of the protocol.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.TryParseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.Azure.SignalR.Protocol.ServiceMessage@)">
            <summary>
            Creates a new <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> from the specified serialized representation.
            </summary>
            <param name="input">The serialized representation of the message.</param>
            <param name="message">When this method returns <c>true</c>, contains the parsed message.</param>
            <returns>A value that is <c>true</c> if the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> was successfully parsed; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.WriteMessage(Microsoft.Azure.SignalR.Protocol.ServiceMessage,System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Writes the specified <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> to a writer.
            </summary>
            <param name="message">The message to write.</param>
            <param name="output">The output writer.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.IServiceProtocol.GetMessageBytes(Microsoft.Azure.SignalR.Protocol.ServiceMessage)">
            <summary>
            Converts the specified <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage"/> to its serialized representation.
            </summary>
            <param name="message">The message to convert.</param>
            <returns>The serialized representation of the message.</returns>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.GroupMember">
            <summary>
            Represents a connection in a group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryResponse.Members">
            <summary>
            The group members.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryResponse.ContinuationToken">
            <summary>
            A token that allows the client to retrieve the next page of results. 
            This parameter is provided by the service in the response of a previous request when there are additional results to be fetched. 
            Clients should include the continuationToken in the next request to receive the subsequent page of data. If this parameter is omitted, the server will return the first page of results.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiPayloadDataMessage">
            <summary>
            Base class for multiple subprotocol data messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiPayloadDataMessage.Payloads">
            <summary>
            Gets or sets the payload dictionary which contains binary payload of multiple protocols.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiPayloadDataMessage.TracingId">
            <summary>
            Gets or sets the tracing Id
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MulticastDataMessage">
            <summary>
            Base class for multicast data messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MulticastDataMessage.Filter">
            <summary>
            Filter out the subscribers to send messages to
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage">
            <summary>
            A data message which will be sent to multiple connections.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage"/> class.
            </summary>
            <param name="connectionList">The list of connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiConnectionDataMessage.ConnectionList">
            <summary>
            Gets or sets the list of connections which will receive this message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.UserDataMessage">
            <summary>
            A data message which will be sent to a user.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.UserDataMessage.UserId">
            <summary>
            Gets or sets the user Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.UserDataMessage.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.UserDataMessage"/> class.
            </summary>
            <param name="userId">The user Id.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage">
            <summary>
            A data message which will be sent to multiple users.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage"/> class.
            </summary>
            <param name="userList">The list of user Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiUserDataMessage.UserList">
            <summary>
            Gets or sets the list of user Ids.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage">
            <summary>
            A data message which will be broadcasted.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.#ctor(System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage"/> class.
            </summary>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.BroadcastDataMessage"/> class.
            </summary>
            <param name="excludedList">The list of excluded connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage">
            <summary>
            A data message which will be broadcasted within a group.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.ExcludedList">
            <summary>
            Gets or sets the list of excluded connection Ids.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.ExcludedUserList">
            <summary>
            Gets or sets the list of excluded user Ids.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.CallerUserId">
            <summary>
            Gets or sets the user ID of the message caller
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.GroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupName">The group name.</param>
            <param name="excludedList">The list of excluded connection Ids.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage">
            <summary>
            A data message which will be broadcasted within multiple groups.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage.GroupList">
            <summary>
            Gets or sets the list of group names.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage.#ctor(System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.MultiGroupBroadcastDataMessage"/> class.
            </summary>
            <param name="groupList">The list of group names.</param>
            <param name="payloads">The payload dictionary which contains binary payload of multiple protocols.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage">
            <summary>
            A data message to indicate a client invocation request.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.#ctor(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.ReadOnlyMemory{System.Byte}},System.Nullable{System.UInt64})">
            <summary>
            Initialize a new instance of <see cref="T:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage"/> class.
            </summary>
            <param name="invocationId">The Id of the client invocation request.</param>
            <param name="connectionId">The client connection Id.</param>
            <param name="callerServerId">The serverId that init the client invocation.</param>
            <param name="payloads">The payload of the message.</param>
            <param name="tracingId">The tracing Id of the message.</param>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.InvocationId">
            <summary>
            Gets or sets the Id of the client invocation request.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.ConnectionId">
            <summary>
            Gets or sets the client connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ClientInvocationMessage.CallerServerId">
            <summary>
            Gets or sets the caller server Id that init the client invocation.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlOperation.Pause">
            <summary>
            Send from ASRS to the app server.
            Asking the client connection to pause sending messages towards ASRS.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlOperation.PauseAck">
            <summary>
            Reply from the app server to ASRS.
            Ackknowledge that the message sending towards ASRS has been pasued.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlOperation.Resume">
            <summary>
            Send from ASRS to the app server.
            Asking the client connection to resume sending messages towards ASRS.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlOperation.Offline">
            <summary>
            Send from ASRS to the app server.
            Asking the app server to send messages through other server connections.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionType.Client">
            <summary>
            Client connection
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.ConnectionType.Server">
            <summary>
            Server connection
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.IAckableMessage">
            <summary>
            Interface of ack-able message
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceMessage">
            <summary>
            Base class of messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceMessage.Clone">
            <summary>
            Clone should make a copy of everything that may get modified throughout the lifetime of the message
            The default implementation is a shallow copy as it fits the current needs.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ExtensibleServiceMessage">
            <summary>
            Base class of messages between Azure SignalR Service and SDK.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlMessage">
            <summary>
            The ASRS send it to the source server connection to initiate a client connection migration.
            Indicates that incoming messages are blocked.
            </summary>
            <param name="connectionId">The client connection ID</param>
            <param name="op">The operation</param>
            <param name="type">The connection type</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlMessage.#ctor(System.String,Microsoft.Azure.SignalR.Protocol.ConnectionFlowControlOperation,Microsoft.Azure.SignalR.Protocol.ConnectionType)">
            <summary>
            The ASRS send it to the source server connection to initiate a client connection migration.
            Indicates that incoming messages are blocked.
            </summary>
            <param name="connectionId">The client connection ID</param>
            <param name="op">The operation</param>
            <param name="type">The connection type</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage">
            <summary>
            An access key request message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.Token">
            <summary>
            Gets or sets the Azure Active Directory token.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.Kid">
            <summary>
            Gets or sets the key Id.
            <c>null</c>
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyRequestMessage"/> class.
            </summary>
            <param name="token"></param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage">
            <summary>
            An access key response message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.Kid">
            <summary>
            Gets or sets the key Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.AccessKey">
            <summary>
            Gets or sets the access key.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.ErrorType">
            <summary>
            Gets or sets error type.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.ErrorMessage">
            <summary>
            Gets or sets error message.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
            <param name="kid"></param>
            <param name="key"></param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AccessKeyResponseMessage"/> class.
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage">
            <summary>
            A handshake request message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.Version">
            <summary>
            Gets or sets the requested protocol version.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.ConnectionType">
            <summary>
            Gets or sets the type of service connection.
            </summary>
            <value>
            <list type="bullet">
            <item>0, Default, it can carry clients, service runtime should always accept this kind of connection.</item>
            <item>1, OnDemand, creating when service requested more connections, it can carry clients, but it may be rejected by service runtime.</item>
            <item>2, Weak, it can not carry clients, but it can send message.</item>
            </list>
            </value>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.Target">
            <summary>
            Gets or sets the target of service connection, only work for OnDemand connections.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.MigrationLevel">
            <summary>
            Gets or sets the migratable flag.
            <value>
            <list type="bullet">
            <item>0, Off, a client connection can not be migrated to another server.</item>
            <item>1, ShutdownOnly, a client connection can be migrated only if the pairing server was shutdown gracefully.</item>
            <item>2, Any, a client connection can be migrated even if the pairing server connection was dropped accidentally. (may cause data loss)</item>
            </list>
            </value>
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.AllowStatefulReconnects">
            <summary>
            Gets or sets the allowing of client stateful reconnects.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage"/> class.
            </summary>
            <param name="version">version</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeRequestMessage"/> class.
            </summary>
            <param name="version">version</param>
            <param name="connectionType">connection type</param>
            <param name="migrationLevel">migration level</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage">
            <summary>
            A handshake response message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.ErrorMessage">
            <summary>
            Gets or sets the optional error message.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.ConnectionId">
            <summary>
            Gets or sets the id of this connection.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.HandshakeResponseMessage"/> class.
            </summary>
            <param name="errorMessage">An optional response error message. A <c>null</c> or empty error message indicates a successful handshake.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.PingMessage">
            <summary>
            A ping message.
            </summary>
        </member>
        <member name="F:Microsoft.Azure.SignalR.Protocol.PingMessage.Instance">
            <summary>
            A static ping message.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage">
            <summary>
            A service error message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage.ErrorMessage">
            <summary>
            Gets or sets the error message
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceErrorMessage"/> class.
            </summary>
            <param name="errorMessage">An error message.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage">
            <summary>
            A service warning message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Type">
            <summary>
            Gets or sets the type of event object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Id">
            <summary>
            Gets or sets the id of event object.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Kind">
            <summary>
            Gets or sets the kind of event.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.Message">
            <summary>
            Gets or sets the message of event.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage.#ctor(Microsoft.Azure.SignalR.Protocol.ServiceEventObjectType,System.String,Microsoft.Azure.SignalR.Protocol.ServiceEventKind,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceEventMessage"/> class.
            </summary>
            <param name="type">A type of event object.</param>
            <param name="id">An id of event object.</param>
            <param name="kind">A kind of event.</param>
            <param name="message">A message of event.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.AckMessage">
            <summary>
            An ack message to response ack-able message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.AckId">
            <summary>
            Gets or sets the ack id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Status">
            <summary>
            Gets or sets the status code
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Message">
            <summary>
            Gets or sets the ack message
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Payload">
            <summary>
            Gets or sets the payload.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AckMessage.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id</param>
            <param name="status">The status code</param>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.AckMessage.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.AckMessage"/> class.
            </summary>
            <param name="ackId">The ack Id</param>
            <param name="status">The status code</param>
            <param name="message">The ack message</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage">
            <summary>
            A message indicates the mapping of client invocation with service instance.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.InvocationId">
            <summary>
            Gets or sets the invocation Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.ConnectionId">
            <summary>
            Gets or sets the connection Id.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.InstanceId">
            <summary>
            Gets or set the service instance Id.
            </summary>
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Azure.SignalR.Protocol.ServiceMappingMessage"/> class.
            </summary>
            <param name="invocationId">The invocation Id.</param>
            <param name="connectionId">The connection Id.</param>
            <param name="instanceId">The service instance Id.</param>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage">
            <summary>
            A message to list connections in a group.
            </summary>
            <remarks>The expected response of this message is an <see cref="T:Microsoft.Azure.SignalR.Protocol.AckMessage"/> whose <see cref="P:Microsoft.Azure.SignalR.Protocol.AckMessage.Payload"/> is a serialized <see cref="T:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryResponse"/>.</remarks>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage.AckId">
            <summary>
            The id to ack.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage.GroupName">
            <summary>
            The name of the group to list.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage.Top">
            <summary>
            The max count of connections to return.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage.ContinuationToken">
            <summary>
            A token to indiate the start point of results.
            This parameter is provided by the service in the response of a previous request when there are additional results to be fetched. 
            Clients should include the continuationToken in the next request to receive the subsequent page of data. If this parameter is omitted, the server will return the first page of results.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.GroupMemberQueryMessage.TracingId">
            <summary>
            The tracing id.
            </summary>
        </member>
        <member name="T:Microsoft.Azure.SignalR.Protocol.ServiceProtocol">
            <summary>
            Implements the Azure SignalR Service Protocol.
            </summary>
        </member>
        <member name="P:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.Version">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.TryParseMessage(System.Buffers.ReadOnlySequence{System.Byte}@,Microsoft.Azure.SignalR.Protocol.ServiceMessage@)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.WriteMessage(Microsoft.Azure.SignalR.Protocol.ServiceMessage,System.Buffers.IBufferWriter{System.Byte})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.Azure.SignalR.Protocol.ServiceProtocol.GetMessageBytes(Microsoft.Azure.SignalR.Protocol.ServiceMessage)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.Azure.SignalR.MemoryBufferWriter.CompletedBuffer">
            <summary>
            Holds a byte[] from the pool and a size value. Basically a Memory but guaranteed to be backed by an ArrayPool byte[], so that we know we can return it.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackReader">
            <summary>
            A primitive types reader for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when reading methods fail due to invalid data.</exception>
            <exception cref="T:System.IO.EndOfStreamException">Thrown by reading methods when there are not enough bytes to read the required value.</exception>
        </member>
        <member name="F:MessagePack.MessagePackReader.reader">
            <summary>
            The reader over the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="memory">The buffer to read from.</param>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
        </member>
        <member name="P:MessagePack.MessagePackReader.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this deserialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Depth">
            <summary>
            Gets or sets the present depth of the object graph being deserialized.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Sequence">
            <summary>
            Gets the <see cref="T:System.Buffers.ReadOnlySequence`1"/> originally supplied to the constructor.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Position">
            <summary>
            Gets the current position of the reader within <see cref="P:MessagePack.MessagePackReader.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Consumed">
            <summary>
            Gets the number of bytes consumed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.End">
            <summary>
            Gets a value indicating whether the reader is at the end of the sequence.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.IsNil">
            <summary>
            Gets a value indicating whether the reader position is pointing at a nil value.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextMessagePackType">
            <summary>
            Gets the next message pack type to be read.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextCode">
            <summary>
            Gets the type of the next MessagePack block.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
            <remarks>
            See <see cref="T:MessagePack.MessagePackCode"/> for valid message pack codes and ranges.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Clone(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct,
            with the same settings as this one, but with its own buffer to read from.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
            <returns>The new reader.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.CreatePeekReader">
            <summary>
            Creates a new <see cref="T:MessagePack.MessagePackReader"/> at this reader's current position.
            The two readers may then be used independently without impacting each other.
            </summary>
            <returns>A new <see cref="T:MessagePack.MessagePackReader"/>.</returns>
            <devremarks>
            Since this is a struct, copying it completely is as simple as returning itself
            from a property that isn't a "ref return" property.
            </devremarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Skip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.TrySkip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <returns><see langword="true"/> if the entire structure beginning at the current <see cref="P:MessagePack.MessagePackReader.Position"/> is found in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>; <see langword="false"/> otherwise.</returns>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            WARNING: when false is returned, the position of the reader is undefined.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadNil">
            <summary>
            Reads a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
            <returns>A nil value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadNil">
            <summary>
            Reads nil if it is the next token.
            </summary>
            <returns><see langword="true"/> if the next token was nil; <see langword="false"/> otherwise.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw(System.Int64)">
            <summary>
            Reads a sequence of bytes without any decoding.
            </summary>
            <param name="length">The number of bytes to read.</param>
            <returns>The sequence of bytes read.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw">
            <summary>
            Reads the next MessagePack primitive.
            </summary>
            <returns>The raw MessagePack sequence.</returns>
            <remarks>
            The entire primitive is read, including content of maps or arrays, or any other type with payloads.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadArrayHeader">
            <summary>
            Read an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadArrayHeader(System.Int32@)">
            <summary>
            Reads an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of elements in the array if the entire array header could be read.</param>
            <returns><see langword="true"/> if there was sufficient buffer and an array header was found; <see langword="false"/> if the buffer incompletely describes an array header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadMapHeader">
            <summary>
            Read a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>.
            </summary>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadMapHeader(System.Int32@)">
            <summary>
            Reads a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of key=value pairs in the map if the entire map header can be read.</param>
            <returns><see langword="true"/> if there was sufficient buffer and a map header was found; <see langword="false"/> if the buffer incompletely describes an map header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBoolean">
            <summary>
            Reads a boolean value from either a <see cref="F:MessagePack.MessagePackCode.False"/> or <see cref="F:MessagePack.MessagePackCode.True"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadChar">
            <summary>
            Reads a <see cref="T:System.Char"/> from any of:
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            or anything between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>A character.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSingle">
            <summary>
            Reads an <see cref="T:System.Single"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDouble">
            <summary>
            Reads an <see cref="T:System.Double"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float64"/>,
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime(MessagePack.ExtensionHeader)">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="header">The extension header that was already read.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBytes">
            <summary>
            Reads a span of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or to support OldSpec compatibility:
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or something between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            A sequence of bytes, or <see langword="null"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSequence">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            The sequence of bytes, or <see langword="null"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadStringSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <param name="span">Receives the span to the string.</param>
            <returns>
            <see langword="true"/> if the string is contiguous in memory such that it could be set as a single span.
            <see langword="false"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/> or the string is not in a contiguous span.
            </returns>
            <remarks>
            Callers should generally be prepared for a <see langword="false"/> result and failover to calling <see cref="M:MessagePack.MessagePackReader.ReadStringSequence"/>
            which can represent a <see langword="null"/> result and handle strings that are not contiguous in memory.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadString">
            <summary>
            Reads a string, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>A string, or <see langword="null"/> if the current msgpack token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormatHeader">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>The extension header.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the bytes the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadExtensionFormatHeader(MessagePack.ExtensionHeader@)">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="extensionHeader">Receives the extension header if the remaining bytes in the <see cref="P:MessagePack.MessagePackReader.Sequence"/> fully describe the header.</param>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormat">
            <summary>
            Reads an extension format header and data, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>
            The extension format.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException(System.Exception)">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInvalidCode(System.Byte)">
            <summary>
            Throws an <see cref="T:MessagePack.MessagePackSerializationException"/> explaining an unexpected code was encountered.
            </summary>
            <param name="code">The code that was encountered.</param>
            <returns>Nothing. This method always throws.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInsufficientBufferUnless(System.Boolean)">
            <summary>
            Throws <see cref="T:System.IO.EndOfStreamException"/> if a condition is false.
            </summary>
            <param name="condition">A boolean value.</param>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if <paramref name="condition"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryGetStringLengthInBytes(System.Int32@)">
            <summary>
            Gets the length of the next string.
            </summary>
            <param name="length">Receives the length of the next string, if there were enough bytes to read it.</param>
            <returns><see langword="true"/> if there were enough bytes to read the length of the next string; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.GetStringLengthInBytes">
            <summary>
            Gets the length of the next string.
            </summary>
            <returns>The length of the next string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSlow(System.Int32)">
            <summary>
            Reads a string assuming that it is spread across multiple spans in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="byteLength">The length of the string to be decoded, in bytes.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadByte">
            <summary>
            Reads an <see cref="T:System.Byte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt16">
            <summary>
            Reads an <see cref="T:System.UInt16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt32">
            <summary>
            Reads an <see cref="T:System.UInt32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt64">
            <summary>
            Reads an <see cref="T:System.UInt64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSByte">
            <summary>
            Reads an <see cref="T:System.SByte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt16">
            <summary>
            Reads an <see cref="T:System.Int16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt64">
            <summary>
            Reads an <see cref="T:System.Int64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="F:MessagePack.SequenceReader`1.usingSequence">
            <summary>
            A value indicating whether we're using <see cref="F:MessagePack.SequenceReader`1.sequence"/> (as opposed to <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.sequence">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.currentPosition">
            <summary>
            The position at the start of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.nextPosition">
            <summary>
            The position at the end of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.memory">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.sequence"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.moreData">
            <summary>
            A value indicating whether there is unread data remaining.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.length">
            <summary>
            The total number of elements in the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.End">
            <summary>
            Gets a value indicating whether there is no more data in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Sequence">
            <summary>
            Gets the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Position">
            <summary>
            Gets the current position in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpan">
            <summary>
            Gets the current segment in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/> as a span.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpanIndex">
            <summary>
            Gets the index in the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.UnreadSpan">
            <summary>
            Gets the unread portion of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Consumed">
            <summary>
            Gets the total number of <typeparamref name="T"/>'s processed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Remaining">
            <summary>
            Gets remaining <typeparamref name="T"/>'s in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Length">
            <summary>
            Gets count of <typeparamref name="T"/> in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryPeek(`0@)">
            <summary>
            Peeks at the next value without advancing the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryRead(`0@)">
            <summary>
            Read the next value and advance the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Rewind(System.Int64)">
            <summary>
            Move the reader back the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.GetNextSpan">
            <summary>
            Get the next segment with available data, if any.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Advance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceCurrentSpan(System.Int64)">
            <summary>
            Unchecked helper to avoid unnecessary checks where you know count is valid.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceWithinSpan(System.Int64)">
            <summary>
            Only call this helper if you know that you are advancing in the current span
            with valid count and there is no need to fetch the next one.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryAdvance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items
            if there are enough elements remaining in the sequence.
            </summary>
            <returns><see langword="true"/> if there were enough elements to advance; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies data from the current <see cref="P:MessagePack.SequenceReader`1.Position"/> to the given <paramref name="destination"/> span.
            </summary>
            <param name="destination">Destination to copy to.</param>
            <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        </member>
        <member name="T:MessagePack.MessagePackSerializationException">
            <summary>
            An exception thrown during serializing an object graph or deserializing a messagepack sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:MessagePack.MessagePackType">
            <summary>
            https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackCode">
            <summary>
            The core type codes as defined by msgpack.
            </summary>
            <seealso href="https://github.com/msgpack/msgpack/blob/master/spec.md#overview" />
        </member>
        <member name="M:MessagePack.MessagePackCode.IsSignedInteger(System.Byte)">
            <summary>
            Checks whether a given messagepack code represents an integer that might include a sign (i.e. might be a negative number).
            </summary>
            <param name="code">The messagepack code.</param>
            <returns>A boolean value.</returns>
        </member>
        <member name="T:MessagePack.ReservedMessagePackExtensionTypeCode">
            <summary>
            The officially defined messagepack extension type codes.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackWriter">
            <summary>
            A primitive types writer for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
        </member>
        <member name="F:MessagePack.MessagePackWriter.writer">
            <summary>
            The writer to use.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="writer">The writer to use.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.MessagePackWriter.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this serialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackWriter.OldSpec">
            <summary>
            Gets or sets a value indicating whether to write in <see href="https://github.com/msgpack/msgpack/blob/master/spec-old.md">old spec</see> compatibility mode.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Clone(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct,
            with the same settings as this one, but with its own buffer writer.
            </summary>
            <param name="writer">The writer to use for the new instance.</param>
            <returns>The new writer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Flush">
            <summary>
            Ensures everything previously written has been flushed to the underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteNil">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.Int32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.UInt32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.Int32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.UInt32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt8(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.SByte)">
            <summary>
            Writes an 8-bit value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt8(System.SByte)">
            <summary>
            Writes an 8-bit value using <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>, or
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> using <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value using either <see cref="F:MessagePack.MessagePackCode.True"/> or <see cref="F:MessagePack.MessagePackCode.False"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Single)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float32"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Double)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float64"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> using the message code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="dateTime">The value to write.</param>
            <exception cref="T:System.NotSupportedException">Thrown when <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is true because the old spec does not define a <see cref="T:System.DateTime"/> format.</exception>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte"/>[], prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if <paramref name="src"/> is <see langword="null"/>.
            </summary>
            <param name="src">The array of bytes to write. May be <see langword="null"/>.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes a sequence of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBinHeader(System.Int32)">
            <summary>
            Writes the header that precedes a raw binary sequence with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="length">The length of bytes that will be written next.</param>
            <remarks>
            <para>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </para>
            <para>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </para>
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteStringHeader(System.Int32)">
            <summary>
            Writes out the header that may precede a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="byteCount">The number of bytes in the string that will follow this header.</param>
            <remarks>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.String)">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if the <paramref name="value"/> is <see langword="null"/>.
            </summary>
            <param name="value">The value to write. May be null.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Char})">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormatHeader(MessagePack.ExtensionHeader)">
            <summary>
            Writes the extension format header, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionHeader">The extension header.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormat(MessagePack.ExtensionResult)">
            <summary>
            Writes an extension format, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionData">The extension data.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)">
            <summary>
            Gets memory where raw messagepack data can be written.
            </summary>
            <param name="length">The minimum length of the returned System.Span`1. If 0, a non-empty buffer is returned.</param>
            <returns>The span of memory to write to. This *may* exceed <paramref name="length"/>.</returns>
            <remarks>
            <para>After initializing the resulting memory, always follow up with a call to <see cref="M:MessagePack.MessagePackWriter.Advance(System.Int32)"/>.</para>
            <para>
            This is similar in purpose to <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            but provides uninitialized memory for the caller to write to instead of copying initialized memory from elsewhere.
            </para>
            </remarks>
            <seealso cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Advance(System.Int32)">
            <summary>
            Commits memory previously returned from <see cref="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)"/> as initialized.
            </summary>
            <param name="length">The number of bytes initialized with messagepack data from the previously returned span.</param>
            <seealso cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt16)">
            <summary>
            Writes a 16-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt32)">
            <summary>
            Writes a 32-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt64)">
            <summary>
            Writes a 64-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Estimates the length of the header required for a given string.
            </summary>
            <param name="characterLength">The length of the string to be written, in characters.</param>
            <param name="bufferSize">Receives the guaranteed length of the returned buffer.</param>
            <param name="encodedBytesOffset">Receives the offset within the returned buffer to write the encoded string to.</param>
            <returns>
            A reference to the first byte in the buffer.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PostEncoding(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Finalizes an encoding of a string.
            </summary>
            <param name="pBuffer">A pointer obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="estimatedOffset">The offset obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="byteCount">The number of bytes used to actually encode the string.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetEncodedLength(System.Int64)">
            <summary>
            Get the number of bytes required to encode a value in msgpack.
            </summary>
            <param name="value">The value to encode.</param>
            <returns>The byte length; One of 1, 2, 3, 5 or 9 bytes.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetEncodedLength(System.UInt64)">
            <summary>
            Get the number of bytes required to encode a value in msgpack.
            </summary>
            <param name="value">The value to encode.</param>
            <returns>The byte length; One of 1, 2, 3, 5 or 9 bytes.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead``1(MessagePack.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of its members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)"/>.
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead(MessagePack.SequenceReader{System.Byte}@,System.SByte@)">
            <summary>
            Reads an <see cref="T:System.SByte"/> from the next position in the sequence.
            </summary>
            <param name="reader">The reader to read from.</param>
            <param name="value">Receives the value read.</param>
            <returns><see langword="true"/> if there was another byte in the sequence; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt16@)">
            <summary>
            Reads an <see cref="T:System.UInt16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt32@)">
            <summary>
            Reads an <see cref="T:System.UInt32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt64@)">
            <summary>
            Reads an <see cref="T:System.UInt64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Single@)">
            <summary>
            Reads a <see cref="T:System.Single"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Single"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Double@)">
            <summary>
            Reads a <see cref="T:System.Double"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Double"/>.</returns>
        </member>
        <member name="T:MessagePack.BufferWriter">
            <summary>
            A fast access struct that wraps <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._output">
            <summary>
            The underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._span">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            Backing field for the <see cref="P:MessagePack.BufferWriter.Span"/> property.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._segment">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._buffered">
            <summary>
            The number of uncommitted bytes (all the calls to <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> since the last call to <see cref="M:MessagePack.BufferWriter.Commit"/>).
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._bytesCommitted">
            <summary>
            The total number of bytes written with this writer.
            Backing field for the <see cref="P:MessagePack.BufferWriter.BytesCommitted"/> property.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="output">The <see cref="T:System.Buffers.IBufferWriter`1"/> to be wrapped.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.BufferWriter.Span">
            <summary>
            Gets the result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.BytesCommitted">
            <summary>
            Gets the total number of bytes written with this writer.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.UnderlyingWriter">
            <summary>
            Gets the <see cref="T:System.Buffers.IBufferWriter`1"/> underlying this instance.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Commit">
            <summary>
            Calls <see cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/> on the underlying writer
            with the number of uncommitted bytes.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Advance(System.Int32)">
            <summary>
            Used to indicate that part of the buffer has been written to.
            </summary>
            <param name="count">The number of bytes written to.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer and calls <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> with the length of the source buffer.
            </summary>
            <param name="source">The buffer to copy in.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Ensure(System.Int32)">
            <summary>
            Acquires a new buffer if necessary to ensure that some given number of bytes can be written to a single buffer.
            </summary>
            <param name="count">The number of bytes that must be allocated in a single buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.TryGetUncommittedSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Gets the span to the bytes written if they were never committed to the underlying buffer writer.
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:MessagePack.BufferWriter.EnsureMore(System.Int32)">
            <summary>
            Gets a fresh span to write to, with an optional minimum size.
            </summary>
            <param name="count">The minimum size for the next requested buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.WriteMultiBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer, potentially across multiple buffers from the underlying writer.
            </summary>
            <param name="source">The buffer to copy into this writer.</param>
        </member>
        <member name="T:MessagePack.SequencePool">
            <summary>
            A thread-safe, alloc-free reusable object pool.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.Shared">
            <summary>
            A thread-safe pool of reusable <see cref="T:Nerdbank.Streams.Sequence`1"/> objects.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.MinimumSpanLength">
            <summary>
            The value to use for <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/>.
            </summary>
            <remarks>
            Individual users that want a different value for this can modify the setting on the rented <see cref="T:Nerdbank.Streams.Sequence`1"/>
            or by supplying their own <see cref="T:System.Buffers.IBufferWriter`1" />.
            </remarks>
            <devremarks>
            We use 32KB so that when LZ4Codec.MaximumOutputLength is used on this length it does not require a
            buffer that would require the Large Object Heap.
            </devremarks>
        </member>
        <member name="F:MessagePack.SequencePool.arrayPool">
            <summary>
            The array pool which we share with all <see cref="T:Nerdbank.Streams.Sequence`1"/> objects created by this <see cref="T:MessagePack.SequencePool"/> instance.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <remarks>
            We use a <see cref="F:MessagePack.SequencePool.maxSize"/> that allows every processor to be involved in messagepack serialization concurrently,
            plus one nested serialization per processor (since LZ4 and sometimes other nested serializations may exist).
            </remarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
            <devremarks>
            We allow 100 arrays to be shared (instead of the default 50) and reduce the max array length from the default 1MB to something more reasonable for our expected use.
            </devremarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32,System.Buffers.ArrayPool{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
            <param name="arrayPool">Array pool that will be used.</param>
        </member>
        <member name="M:MessagePack.SequencePool.Rent">
            <summary>
            Gets an instance of <see cref="T:Nerdbank.Streams.Sequence`1"/>
            This is taken from the recycled pool if one is available; otherwise a new one is created.
            </summary>
            <returns>The rental tracker that provides access to the object as well as a means to return it.</returns>
        </member>
        <member name="P:MessagePack.SequencePool.Rental.Value">
            <summary>
            Gets the recyclable object.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.Rental.Dispose">
            <summary>
            Returns the recyclable object to the pool.
            </summary>
            <remarks>
            The instance is cleaned first, if a clean delegate was provided.
            It is dropped instead of being returned to the pool if the pool is already at its maximum size.
            </remarks>
        </member>
        <member name="T:MessagePack.Utilities">
            <summary>
            Internal utilities and extension methods for various external types.
            </summary>
        </member>
        <member name="F:MessagePack.Utilities.IsMono">
            <summary>
            A value indicating whether we're running on mono.
            </summary>
        </member>
        <member name="M:MessagePack.Utilities.GetEntryEnumerator(System.Collections.IDictionary)">
            <summary>
            Gets an <see cref="T:System.Collections.IDictionary"/> enumerator that does not allocate for each entry,
            and that doesn't produce the nullable ref annotation warning about unboxing a possibly null value.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.Sequence`1">
            <summary>
            Manages a sequence of elements, readily castable as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <typeparam name="T">The type of element stored by the sequence.</typeparam>
            <remarks>
            Instance members are not thread-safe.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class
            that uses a private <see cref="T:System.Buffers.ArrayPool`1"/> for recycling arrays.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.MemoryPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="memoryPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="arrayPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength">
            <summary>
            Gets or sets the minimum length for any array allocated as a segment in the sequence.
            Any non-positive value allows the pool to determine the length of the array.
            </summary>
            <value>The default value is 0.</value>
            <remarks>
            <para>
            Each time <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> is called,
            previously allocated memory is used if it is large enough to satisfy the length demand.
            If new memory must be allocated, the argument to one of these methods typically dictate
            the length of array to allocate. When the caller uses very small values (just enough for its immediate need)
            but the high level scenario can predict that a large amount of memory will be ultimately required,
            it can be advisable to set this property to a value such that just a few larger arrays are allocated
            instead of many small ones.
            </para>
            <para>
            The <see cref="T:System.Buffers.MemoryPool`1"/> in use may itself have a minimum array length as well,
            in which case the higher of the two minimums dictate the minimum array size that will be allocated.
            </para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AsReadOnlySequence">
            <summary>
            Gets this sequence expressed as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <returns>A read only sequence representing the data in this object.</returns>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.Length">
            <summary>
            Gets the length of the sequence.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.DebuggerDisplay">
            <summary>
            Gets the value to display in a debugger datatip.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.op_Implicit(Nerdbank.Streams.Sequence{`0})~System.Buffers.ReadOnlySequence{`0}">
            <summary>
            Expresses this sequence as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="sequence">The sequence to convert.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)">
            <summary>
            Removes all elements from the sequence from its beginning to the specified position,
            considering that data to have been fully processed.
            </summary>
            <param name="position">
            The position of the first element that has not yet been processed.
            This is typically <see cref="P:System.Buffers.ReadOnlySequence`1.End"/> after reading all elements from that instance.
            </param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)">
            <summary>
            Advances the sequence to include the specified number of elements initialized into memory
            returned by a prior call to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/>.
            </summary>
            <param name="count">The number of elements written into memory.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Dispose">
            <summary>
            Clears the entire sequence, recycles associated memory into pools,
            and resets this instance for reuse.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Reset">
            <summary>
            Clears the entire sequence and recycles associated memory into pools.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.IsValueTypeElement">
            <summary>
            A value indicating whether the element is a value type.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array">
            <summary>
            Gets the backing array, when using an <see cref="T:System.Buffers.ArrayPool`1"/> instead of a <see cref="T:System.Buffers.MemoryPool`1"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Start">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data starts.
            </summary>
            <remarks>This may be nonzero as a result of calling <see cref="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)"/>.</remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data ends.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingMemory">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingSpan">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner">
            <summary>
            Gets the tracker for the underlying array for this segment, which can be used to recycle the array when we're disposed of.
            Will be <c>null</c> if using an array pool, in which case the memory is held by <see cref="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.AvailableMemory">
            <summary>
            Gets the full memory owned by the <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length">
            <summary>
            Gets the number of elements that are committed in this segment.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.WritableBytes">
            <summary>
            Gets the amount of writable bytes in this segment.
            It is the amount of bytes between <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length"/> and <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Next">
            <summary>
            Gets or sets the next segment in the singly linked list of segments.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(System.Buffers.IMemoryOwner{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memoryOwner">The memory and a means to recycle it.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(`0[])">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="array">An array drawn from an <see cref="T:System.Buffers.ArrayPool`1"/>.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.ResetMemory(System.Buffers.ArrayPool{`0})">
            <summary>
            Clears all fields in preparation to recycle this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.SetNext(Nerdbank.Streams.Sequence{`0}.SequenceSegment)">
            <summary>
            Adds a new segment after this one.
            </summary>
            <param name="segment">The next segment in the linked list.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Advance(System.Int32)">
            <summary>
            Commits more elements as written in this segment.
            </summary>
            <param name="count">The number of elements written.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AdvanceTo(System.Int32)">
            <summary>
            Removes some elements from the start of this segment.
            </summary>
            <param name="offset">The number of elements to ignore from the start of the underlying array.</param>
        </member>
    </members>
</doc>
